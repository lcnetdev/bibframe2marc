<?xml version="1.0" encoding="UTF-8"?>

<x:description xmlns:x="http://www.jenitennison.com/xslt/xspec"
               xmlns:xslt="http://www.w3.org/1999/XSL/Transform"
               xmlns:xslout="http://www.w3.org/1999/XSL/Transform"
               xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
               xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
               xmlns:marc="http://www.loc.gov/MARC21/slim"
               xmlns:bf="http://id.loc.gov/ontologies/bibframe/"
               xmlns:bflc="http://id.loc.gov/ontologies/bflc/"
               xmlns:madsrdf="http://www.loc.gov/mads/rdf/v1#"
               xmlns:bf2marc="http://www.loc.gov/bf2marc"
               xmlns:local="http://example.org/local"
               stylesheet="../src/compile.xsl" xslt-version="1.0">

  <x:scenario label="Basic regression">
    <x:context href="data/minimal.xml"/>
    <x:expect label="...should match expected">
      <xslt:stylesheet xmlns:exsl="http://exslt.org/common"
                       xmlns:date="http://exslt.org/dates-and-times"
                       xmlns:fn="http://www.w3.org/2005/xpath-functions"
                       xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                       xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
                       xmlns:marc="http://www.loc.gov/MARC21/slim"
                       xmlns:bf="http://id.loc.gov/ontologies/bibframe/"
                       xmlns:bflc="http://id.loc.gov/ontologies/bflc/"
                       xmlns:madsrdf="http://www.loc.gov/mads/rdf/v1#"
                       xmlns:xslt="http://www.w3.org/1999/XSL/Transform"
                       xmlns:local="http://example.org/local"
                       version="1.0"
                       extension-element-prefixes="exsl date"
                       exclude-result-prefixes="fn rdf rdfs bf bflc madsrdf local">
        <xslt:output encoding="UTF-8" method="xml" indent="yes"/>
        <xslt:strip-space elements="*"/>
        <xslt:param name="pRecordId" select="'default'"/>
        <xslt:param name="pCatScript" select="'Latn'" />
        <xslt:param name="pGenerationDatestamp">
          <xslt:choose>
            <xslt:when test="function-available('date:date-time')">
              <xslt:value-of select="concat(translate(substring(date:date-time(),1,19),'-:T',''),'.0')"/>
            </xslt:when>
            <xslt:when test="function-available('fn:current-dateTime')">
              <xslt:value-of select="concat(translate(substring(fn:current-dateTime(),1,19),'-:T',''),'.0')"/>
            </xslt:when>
          </xslt:choose>
        </xslt:param>
        <xslt:param name="pSourceRecordId"/>
        <xslt:param name="pConversionAgency" select="'DLC'"/>
        <xslt:param name="pGenerationUri" select="'https://github.com/lcnetdev/bibframe2marc'"/>
        <xslt:variable name="lower">abcdefghijklmnopqrstuvwxyz</xslt:variable>
        <xslt:variable name="upper">ABCDEFGHIJKLMNOPQRSTUVWXYZ</xslt:variable>
        <xslt:variable name="vCurrentVersion">0.1.0-TEST</xslt:variable>
        <xslt:template match="/">
          <xslt:choose>
            <xslt:when test="rdf:RDF">
              <xslt:choose>
                <xslt:when test="count(rdf:RDF/bf:Instance) = 1">
                  <xslt:choose>
                    <xslt:when test="count(rdf:RDF/bf:Work) = 0" />
                    <xslt:when test="count(rdf:RDF/bf:Work) = 1">
                      <xslt:choose>
                        <xslt:when test="rdf:RDF/bf:Instance/bf:instanceOf[@rdf:resource=/rdf:RDF/bf:Work/@rdf:about]" />
                        <xslt:when test="rdf:RDF/bf:Work/bf:hasInstance[@rdf:resource=/rdf:RDF/bf:Instance/@rdf:about]" />
                        <xslt:otherwise>
                          <xslt:message terminate="yes">Invalid document: top-level Instance and Work are not linked</xslt:message>
                        </xslt:otherwise>
                      </xslt:choose>
                    </xslt:when>
                    <xslt:otherwise>
                      <xslt:message terminate="yes">Invalid document: document can only have 0 or 1 top-level Work element</xslt:message>
                    </xslt:otherwise>
                  </xslt:choose>
                </xslt:when>
                <xslt:otherwise>
                  <xslt:message terminate="yes">Invalid document: document must have exactly one top-level Instance element</xslt:message>
                </xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:otherwise>
              <xslt:message terminate="yes">Invalid document: no RDF root element</xslt:message>
            </xslt:otherwise>
          </xslt:choose>
          <xslt:apply-templates/>
        </xslt:template>
        <xslt:template match="rdf:RDF">
          <xslt:variable name="vAdminMetadata" select="bf:Instance/bf:adminMetadata/bf:AdminMetadata | bf:Work/bf:adminMetadata/bf:AdminMetadata[not(/rdf:RDF/bf:Instance/bf:adminMetadata/bf:AdminMetadata)]" />
          <xslt:variable name="vRecordId">
            <xslt:choose>
              <xslt:when test="$pRecordId = 'default'">
                <xslt:choose>
                  <xslt:when test="$vAdminMetadata/bf:identifiedBy/bf:Local[not(bf:source) or bf:source/@rdf:resource='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/@rdf:about='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/rdfs:label='DLC']/rdf:value">
                    <xslt:value-of select="$vAdminMetadata/bf:identifiedBy/bf:Local[not(bf:source) or bf:source/@rdf:resource='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/@rdf:about='http://id.loc.gov/vocabulary/organizations/dlc' or bf:source/bf:Source/rdfs:label='DLC']/rdf:value" />
                  </xslt:when>
                  <xslt:otherwise>
                    <xslt:value-of select="generate-id()" />
                  </xslt:otherwise>
                </xslt:choose>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$pRecordId" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <marc:record/>
        </xslt:template>
        <xslt:template match="text()"/>
        <xslt:template name="tChopPunct">
          <xslt:param name="pString"/>
          <xslt:variable name="vNormString" select="normalize-space($pString)"/>
          <xslt:variable name="vPunct" select="':;,/=&#x2013;&#x2014;'"/>
          <xslt:variable name="vEndEnclose" select="')]}}&quot;'"/>
          <xslt:variable name="vLength" select="string-length($vNormString)"/>
          <xslt:choose>
            <xslt:when test="$vLength=0"/>
            <xslt:when test="not($vNormString)"/>
            <xslt:when test="substring($vNormString,1,1) = '('">
              <xslt:variable name="vCloseIndex">
                <xslt:call-template name="tLastIndex">
                  <xslt:with-param name="pString" select="$vNormString"/>
                  <xslt:with-param name="pSearch" select="')'"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:choose>
                <xslt:when test="$vCloseIndex &gt; 2">
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="concat(substring($vNormString,2,$vCloseIndex - 2),substring($vNormString,$vCloseIndex+1))"/>
                  </xslt:call-template>
                </xslt:when>
                <xslt:otherwise>
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="substring($vNormString,2)"/>
                  </xslt:call-template>
                </xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:when test="substring($vNormString,1,1) = '['">
              <xslt:variable name="vCloseIndex">
                <xslt:call-template name="tLastIndex">
                  <xslt:with-param name="pString" select="$vNormString"/>
                  <xslt:with-param name="pSearch" select="']'"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:choose>
                <xslt:when test="$vCloseIndex &gt; 2">
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="concat(substring($vNormString,2,$vCloseIndex - 2),substring($vNormString,$vCloseIndex+1))"/>
                  </xslt:call-template>
                </xslt:when>
                <xslt:otherwise>
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="substring($vNormString,2)"/>
                  </xslt:call-template>
                </xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:when test="substring($vNormString,1,1) = '{{'">
              <xslt:variable name="vCloseIndex">
                <xslt:call-template name="tLastIndex">
                  <xslt:with-param name="pString" select="$vNormString"/>
                  <xslt:with-param name="pSearch" select="'}}'"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:choose>
                <xslt:when test="$vCloseIndex &gt; 2">
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="concat(substring($vNormString,2,$vCloseIndex - 2),substring($vNormString,$vCloseIndex+1))"/>
                  </xslt:call-template>
                </xslt:when>
                <xslt:otherwise>
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="substring($vNormString,2)"/>
                  </xslt:call-template>
                </xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:when test="substring($vNormString,1,1) = '&quot;'">
              <xslt:variable name="vCloseIndex">
                <xslt:call-template name="tLastIndex">
                  <xslt:with-param name="pString" select="$vNormString"/>
                  <xslt:with-param name="pSearch" select="'&quot;'"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:choose>
                <xslt:when test="$vCloseIndex &gt; 2">
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="concat(substring($vNormString,2,$vCloseIndex - 2),substring($vNormString,$vCloseIndex+1))"/>
                  </xslt:call-template>
                </xslt:when>
                <xslt:otherwise>
                  <xslt:call-template name="tChopPunct">
                    <xslt:with-param name="pString" select="substring($vNormString,2)"/>
                  </xslt:call-template>
                </xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:when test="substring($vNormString,$vLength,1) = '.'">
              <xslt:choose>
                <xslt:when test="contains(concat($vPunct,$vEndEnclose),substring($vNormString,$vLength - 1,1))">
	                <xslt:call-template name="tChopPunct">
	                  <xslt:with-param name="pString" select="substring($vNormString,1,$vLength - 1)"/>
	                </xslt:call-template>
                </xslt:when>
                <xslt:otherwise><xslt:value-of select="$vNormString"/></xslt:otherwise>
              </xslt:choose>
            </xslt:when>
            <xslt:when test="contains($vPunct, substring($vNormString,$vLength,1))">
	            <xslt:call-template name="tChopPunct">
	              <xslt:with-param name="pString" select="substring($vNormString,1,$vLength - 1)"/>
	            </xslt:call-template>
            </xslt:when>
            <xslt:when test="substring($vNormString,$vLength,1)=')' and not(contains($vNormString,'('))">
	            <xslt:call-template name="tChopPunct">
	              <xslt:with-param name="pString" select="substring($vNormString,1,$vLength - 1)"/>
	            </xslt:call-template>
            </xslt:when>
            <xslt:when test="substring($vNormString,$vLength,1)=']' and not(contains($vNormString,'['))">
	            <xslt:call-template name="tChopPunct">
	              <xslt:with-param name="pString" select="substring($vNormString,1,$vLength - 1)"/>
	            </xslt:call-template>
            </xslt:when>
            <xslt:when test="substring($vNormString,$vLength,1)='}}' and not(contains($vNormString,'{{'))">
	            <xslt:call-template name="tChopPunct">
	              <xslt:with-param name="pString" select="substring($vNormString,1,$vLength - 1)"/>
	            </xslt:call-template>
            </xslt:when>
            <xslt:when test="substring($vNormString,$vLength,1)='&quot;' and not(contains($vNormString,'&quot;'))">
	            <xslt:call-template name="tChopPunct">
	              <xslt:with-param name="pString" select="substring($vNormString,1,$vLength - 1)"/>
	            </xslt:call-template>
            </xslt:when>
            <xslt:otherwise>
	            <xslt:value-of select="$vNormString"/>
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="tLastIndex">
          <xslt:param name="pString"/>
          <xslt:param name="pSearch"/>
          <xslt:choose>
            <xslt:when test="$pSearch != '' and contains($pString,$pSearch)">
              <xslt:variable name="vRevSearch">
                <xslt:call-template name="tReverseString">
                  <xslt:with-param name="pString" select="$pSearch"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:variable name="vRevString">
                <xslt:call-template name="tReverseString">
                  <xslt:with-param name="pString" select="$pString"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:value-of select="string-length($pString) - string-length(substring-before($vRevString,$vRevSearch))"/>
            </xslt:when>
            <xslt:otherwise>0</xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="tReverseString">
          <xslt:param name="pString"/>
          <xslt:variable name="vLength" select="string-length($pString)"/>
          <xslt:choose>
            <xslt:when test="$vLength &lt; 2"><xslt:value-of select="$pString"/></xslt:when>
            <xslt:when test="$vLength = 2">
              <xslt:value-of select="concat(substring($pString,2,1),substring($pString,1,1))"/>
            </xslt:when>
            <xslt:otherwise>
              <xslt:variable name="vMid" select="floor($vLength div 2)"/>
              <xslt:variable name="vHalf1">
                <xslt:call-template name="tReverseString">
                  <xslt:with-param name="pString" select="substring($pString,1,$vMid)"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:variable name="vHalf2">
                <xslt:call-template name="tReverseString">
                  <xslt:with-param name="pString" select="substring($pString,$vMid+1)"/>
                </xslt:call-template>
              </xslt:variable>
              <xslt:value-of select="concat($vHalf2,$vHalf1)"/>
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="tPadRight">
          <xslt:param name="pInput" />
          <xslt:param name="pPadChar"
                      select="' '" />
          <xslt:param name="pStringLength"
                      select="string-length($pInput)" />
          <xslt:choose>
            <xslt:when test="string-length($pInput) >= $pStringLength">
              <xslt:value-of select="$pInput" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:call-template name="tPadRight">
                <xslt:with-param name="pInput"
                                 select="concat($pInput,$pPadChar)" />
                <xslt:with-param name="pPadChar"
                                 select="$pPadChar" />
                <xslt:with-param name="pStringLength"
                                 select="$pStringLength" />
              </xslt:call-template>
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="tPadLeft">
          <xslt:param name="pInput" />
          <xslt:param name="pPadChar"
                      select="' '" />
          <xslt:param name="pStringLength"
                      select="string-length($pInput)" />
          <xslt:choose>
            <xslt:when test="string-length($pInput) >= $pStringLength">
              <xslt:value-of select="$pInput" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:call-template name="tPadLeft">
                <xslt:with-param name="pInput"
                                 select="concat($pPadChar,$pInput)" />
                <xslt:with-param name="pPadChar"
                                 select="$pPadChar" />
                <xslt:with-param name="pStringLength"
                                 select="$pStringLength" />
              </xslt:call-template>
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-Date1">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains($pEDTFDate,'/')">
              <xslt:value-of select="substring-before($pEDTFDate,'/')" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:value-of select="$pEDTFDate" />
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-Date2">
          <xslt:param name="pEDTFDate" />
          <xslt:value-of select="substring-after($pEDTFDate,'/')" />
        </xslt:template>
        <xslt:template name="EDTF-DatePart">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains($pEDTFDate,'T')">
              <xslt:value-of select="substring-before($pEDTFDate,'T')" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:value-of select="$pEDTFDate" />
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-TimePart">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'+')">
              <xslt:value-of select="substring-before(substring-after($pEDTFDate,'T'),'+')" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'-')">
              <xslt:value-of select="substring-before(substring-after($pEDTFDate,'T'),'-')" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'Z')">
              <xslt:value-of select="substring-before(substring-after($pEDTFDate,'T'),'Z')" />
            </xslt:when>
            <xslt:otherwise>
              <xslt:value-of select="substring-after($pEDTFDate,'T')" />
            </xslt:otherwise>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-TimeDiff">
          <xslt:param name="pEDTFDate" />
          <xslt:choose>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'+')">
              <xslt:value-of select="concat('+',substring-after(substring-after($pEDTFDate,'T'),'+'))" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'-')">
              <xslt:value-of select="concat('-',substring-after(substring-after($pEDTFDate,'T'),'-'))" />
            </xslt:when>
            <xslt:when test="contains(substring-after($pEDTFDate,'T'),'Z')">+00:00</xslt:when>
          </xslt:choose>
        </xslt:template>
        <xslt:template name="EDTF-to-033">
          <xslt:param name="pEDTFDate" />
          <xslt:variable name="vEDTFDate"
                         select="translate(translate(translate($pEDTFDate,'?',''),'~',''),'%','')" />
          <xslt:variable name="vDatePart">
            <xslt:call-template name="EDTF-DatePart">
              <xslt:with-param name="pEDTFDate"
                               select="$vEDTFDate" />
            </xslt:call-template>
          </xslt:variable>
          <xslt:variable name="vTimePart">
            <xslt:call-template name="EDTF-TimePart">
              <xslt:with-param name="pEDTFDate"
                               select="$vEDTFDate" />
            </xslt:call-template>
          </xslt:variable>
          <xslt:variable name="vTimeDiffPart">
            <xslt:call-template name="EDTF-TimeDiff">
              <xslt:with-param name="pEDTFDate"
                               select="$vEDTFDate" />
            </xslt:call-template>
          </xslt:variable>
          <xslt:variable name="vYear">
            <xslt:variable name="vYear033">
              <xslt:choose>
                <xslt:when test="contains($vDatePart,'-')">
                  <xslt:value-of select="translate(substring-before($vDatePart,'-'),'X','-')" />
                </xslt:when>
                <xslt:otherwise>
                  <xslt:value-of select="translate($vDatePart,'X','-')" />
                </xslt:otherwise>
              </xslt:choose>
            </xslt:variable>
            <xslt:choose>
              <xslt:when test="starts-with($vYear033,'Y') or starts-with($vYear033,'-') or (string-length($vYear033) != 4)">
                <xslt:text>----</xslt:text>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$vYear033" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <xslt:variable name="vMonth">
            <xslt:variable name="vMonth033">
              <xslt:choose>
                <xslt:when test="substring-after(substring-after($vDatePart,'-'),'-') != ''">
                  <xslt:value-of select="translate(substring-before(substring-after($vDatePart,'-'),'-'),'X','-')" />
                </xslt:when>
                <xslt:otherwise>
                  <xslt:value-of select="translate(substring-after($vDatePart,'-'),'X','-')" />
                </xslt:otherwise>
              </xslt:choose>
            </xslt:variable>
            <xslt:choose>
              <xslt:when test="(string-length($vMonth033) != 2) or ($vMonth033 > 12)">
                <xslt:text>--</xslt:text>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$vMonth033" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <xslt:variable name="vDay">
            <xslt:variable name="vDay033"
                           select="translate(substring-after(substring-after($vDatePart,'-'),'-'),'X','-')" />
            <xslt:choose>
              <xslt:when test="(string-length($vDay033) != 2) or ($vDay033 > 31)">
                <xslt:text>--</xslt:text>
              </xslt:when>
              <xslt:otherwise>
                <xslt:value-of select="$vDay033" />
              </xslt:otherwise>
            </xslt:choose>
          </xslt:variable>
          <xslt:variable name="vTime">
            <xslt:if test="$vTimePart != ''">
              <xslt:variable name="vTime033"
                             select="translate(translate($vTimePart,'X','-'),':','')" />
              <xslt:choose>
                <xslt:when test="string-length($vTime033) = 6">
                  <xslt:value-of select="$vTime033" />
                </xslt:when>
                <xslt:otherwise>------</xslt:otherwise>
              </xslt:choose>
            </xslt:if>
          </xslt:variable>
          <xslt:variable name="vTimeDiff">
            <xslt:if test="($vTimePart != '') and ($vTimeDiffPart != '')">
              <xslt:variable name="vTimeDiff033"
                             select="translate(translate($vTimeDiffPart,'X','-'),':','')" />
              <xslt:choose>
                <xslt:when test="string-length($vTimeDiff033) = 5">
                  <xslt:value-of select="$vTimeDiff033" />
                </xslt:when>
                <xslt:when test="string-length($vTimeDiff033) = 3">
                  <xslt:value-of select="concat($vTimeDiff033,'00')" />
                </xslt:when>
              </xslt:choose>
            </xslt:if>
          </xslt:variable>
          <xslt:value-of select="concat($vYear,$vMonth,$vDay,$vTime,$vTimeDiff)" />
        </xslt:template>
        <xslt:template name="tScriptCode">
          <xslt:param name="pXmlLang" />
          <xslt:if test="string-length($pXmlLang) >= 4">
            <xslt:choose>
              <xslt:when test="string-length($pXmlLang)=4 and translate(substring($pXmlLang,1,1),0123456789,'') != ''">
                <xslt:value-of select="$pXmlLang" />
              </xslt:when>
              <xslt:when test="string-length(substring-before($pXmlLang,'-'))=4 and translate(substring($pXmlLang,1,1),0123456789,'') != ''">
                <xslt:value-of select="substring-before($pXmlLang,'-')" />
              </xslt:when>
              <xslt:otherwise>
                <xslt:call-template name="tScriptCode">
                  <xslt:with-param name="pXmlLang" select="substring-after($pXmlLang,'-')" />
                </xslt:call-template>
              </xslt:otherwise>
            </xslt:choose>
          </xslt:if>
        </xslt:template>
      </xslt:stylesheet>
    </x:expect>
  </x:scenario>

  <x:scenario label="Load rules from included files">
    <x:context href="data/file.xml"/>
    <x:expect label="...should create transforms for all included files"
              test="count(//marc:leader)=1 and count(//marc:controlfield)=3"/>
  </x:scenario>

  <x:scenario label="map element">
    <x:context mode="map">
      <bf2marc:map name="instruments">
        <instrument>
          <code>ba</code>
          <type>brass</type>
          <label>horn</label>
        </instrument>
        <instrument>
          <code>bb</code>
          <type>brass</type>
          <label>trumpet</label>
        </instrument>
      </bf2marc:map>
    </x:context>
    <x:expect label="...should generate a variable with the embedded XML data structure">
      <xslt:variable name="instruments">
        <instrument>
          <code>ba</code>
          <type>brass</type>
          <label>horn</label>
        </instrument>
        <instrument>
          <code>bb</code>
          <type>brass</type>
          <label>trumpet</label>
        </instrument>
      </xslt:variable>
    </x:expect>
  </x:scenario>

  <x:scenario label="key element">
    <x:context mode="key">
      <bf2marc:key name="kMusicMediumSource" match="bf:MusicMedium" use="bf:source/bf:Source/rdfs:label"/>
    </x:context>
    <x:expect label="...should generate an XSL key">
      <xslt:key name="kMusicMediumSource" match="bf:MusicMedium" use="bf:source/bf:Source/rdfs:label"/>
    </x:expect>
  </x:scenario>

  <x:scenario label="Document frame">
    <x:scenario label="Rule without context element">
      <x:context mode="documentFrame">
        <bf2marc:cf tag="001"/>
      </x:context>
      <x:expect label="...should generate a frame for the target MARC element">
        <marc:controlfield>
          <xslt:attribute name="tag">001</xslt:attribute>
        </marc:controlfield>
      </x:expect>
    </x:scenario>

    <x:scenario label="Rule with context element">
      <x:context mode="documentFrame">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate an apply-templates element">
        <xslt:apply-templates select="bf:Instance" mode="generate-001">
          <xslt:with-param name="vRecordId" select="$vRecordId"/>
          <xslt:with-param name="vAdminMetadata" select="$vAdminMetadata"/>
        </xslt:apply-templates>
      </x:expect>
    </x:scenario>

    <x:scenario label="Transform within document frame">
      <x:context mode="documentFrame">
        <bf2marc:transform>
          <xslout:text>test</xslout:text>
        </bf2marc:transform>
      </x:context>
      <x:expect label="...XSL should be copied into output stylesheet">
        <xslt:text>test</xslt:text>
      </x:expect>
    </x:scenario>

    <x:scenario label="lang-prefer attribute on non-repeatable field">
      <x:context mode="documentFrame">
        <bf2marc:df tag="245" repeatable="false" lang-xpath="bf:mainTitle" lang-prefer="vernacular">
          <bf2marc:context xpath="bf:Instance/bf:title/bf:Title[not(rdf:type)]"/>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should select nodes to process based on lang-xpath and default script"
                test="//xslt:for-each[1]/@select='bf:Instance/bf:title/bf:Title[not(rdf:type)][bf:mainTitle/@xml:lang and not(contains(translate(bf:mainTitle/@xml:lang,$upper,$lower),translate($pCatScript,$upper,$lower)))]'"/>
    </x:scenario>

    <x:scenario label="lang-prefer attribute on repeatable fields">
      <x:context mode="documentFrame">
        <bf2marc:df tag="250" lang-xpath="." lang-prefer="vernacular">
          <bf2marc:context xpath="bf:Instance/bf:editionStatement"/>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should also select nodes based on lang-xpath and default script"
                test="//xslt:for-each[1]/@select='bf:Instance/bf:editionStatement[./@xml:lang and not(contains(translate(./@xml:lang,$upper,$lower),translate($pCatScript,$upper,$lower)))]'"/>
    </x:scenario>
  </x:scenario>

  <x:scenario label="Template generation">
    <x:scenario label="Rule with context element">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate a template for transforming the matched node into the specified MARC element"
                test="xslt:template/@match='bf:Instance' and xslt:template/@mode='generate-001'"/>
    </x:scenario>

    <x:scenario label="Context with var element">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance">
            <bf2marc:var name="vTestVar">
              <bf2marc:switch>
                <bf2marc:case test="bf:edition">some value</bf2marc:case>
              </bf2marc:switch>
            </bf2marc:var>
          </bf2marc:context>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate a template with locally-scoped xsl variable"
                test="xslt:template/xslt:variable/@name = 'vTestVar'"/>
    </x:scenario>

    <x:scenario label="Non-repeatable field">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...source element should only pass through template once"
                test="xslt:template/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>
  </x:scenario>

  <x:scenario label="MARC field frame">
    <x:scenario label="cf element">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001"/>
      </x:context>
      <x:expect label="...should generate frame for target MARC control field">
        <marc:controlfield>
          <xslt:attribute name="tag">001</xslt:attribute>
        </marc:controlfield>
      </x:expect>
    </x:scenario>

    <x:scenario label="cf element with tag='LDR'">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="LDR"/>
      </x:context>
      <x:expect label="...should generate frame for MARC leader">
        <marc:leader/>
      </x:expect>
    </x:scenario>

    <x:scenario label="bare value in cf">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001">12345678</bf2marc:cf>
      </x:context>
      <x:expect label="...should generate frame for target MARC control field with bare value"
                test="marc:controlfield/xslt:attribute[@name='tag']='001' and marc:controlfield/xslt:text='12345678'"/>
    </x:scenario>

    <x:scenario label="Processing rules in cf or df element">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001">
          <bf2marc:select xpath="bf:Instance">12345678</bf2marc:select>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should generate XSL logic for processing document"
                test="count(marc:controlfield/xslt:for-each)=1"/>
    </x:scenario>

    <x:scenario label="chopPunct attribute in cf">
      <x:context mode="fieldTemplate">
        <bf2marc:cf tag="001" chopPunct="true">
          <bf2marc:select xpath="bf:Instance/bf:adminMetadata/bf:AdminMetadata/bf:identifiedBy/bf:Local/rdf:value"/>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should call tChopPunct template to process value"
                test="count(//xslt:call-template[@name='tChopPunct']) = 1"/>
    </x:scenario>

    <x:scenario label="df element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245"/>
      </x:context>
      <x:expect label="...should generate frame for target MARC data field">
        <marc:datafield>
          <xslt:attribute name="tag">245</xslt:attribute>
        </marc:datafield>
      </x:expect>
    </x:scenario>

    <x:scenario label="lang-xpath attribute">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245" lang-xpath="bf:mainTitle"/>
      </x:context>
      <x:expect label="...should generate xml:lang attribute for target MARC data field"
                test="marc:datafield/xslt:if/xslt:attribute/@name='xml:lang'"/>
    </x:scenario>

    <x:scenario label="variable as tag name">
      <x:context mode="generateTemplates">
        <bf2marc:df tag="$vTestTagVar">
          <bf2marc:context xpath="bf:Work/bf:title/bf:Title|bf:Instance/bf:title/bf:Title">
            <bf2marc:var name="vtestTagVar">
              <bf2marc:switch>
                <bf2marc:case test="local-name(../..)='Work'">130</bf2marc:case>
                <bf2marc:case test="local-name(../..)='Instance'">245</bf2marc:case>
              </bf2marc:switch>
            </bf2marc:var>
            <bf2marc:ind1 default=" "/>
            <bf2marc:ind2 default=" "/>
          </bf2marc:context>
        </bf2marc:df>
      </x:context>
      <x:expect label="should generate field template with variable substitution"
                test="xslt:template/marc:datafield/xslt:attribute/xslt:value-of/@select = '$vTestTagVar'"/>
    </x:scenario>

    <x:scenario label="ind1 or ind2 element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:ind1>1</bf2marc:ind1>
          <bf2marc:ind2>0</bf2marc:ind2>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should generate ind1/ind2 attributes of target MARC data field">
        <marc:datafield>
          <xslt:attribute name="tag">245</xslt:attribute>
          <xslt:attribute name="ind1"><xslt:text>1</xslt:text></xslt:attribute>
          <xslt:attribute name="ind2"><xslt:text>0</xslt:text></xslt:attribute>
        </marc:datafield>
      </x:expect>
    </x:scenario>

    <x:scenario label="default attribute for ind1 or ind2 element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:ind1 default="1"/>
          <bf2marc:ind2 default="0">
            <bf2marc:select xpath="bf:code"/>
          </bf2marc:ind2>
        </bf2marc:df>
      </x:context>
      <x:expect label="...sets the default value for the ind1/ind2 attributes"
                test="marc:datafield/xslt:attribute[@name='ind1']/xslt:text='1' and
                      marc:datafield/xslt:attribute[@name='ind2']/xslt:choose/xslt:otherwise/xslt:text='0'"/>
    </x:scenario>

    <x:scenario label="sf element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:sf code="a"/>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should create frame for target MARC subfield"
                test="count(marc:datafield//marc:subfield[@code='a'])=1"/>
    </x:scenario>

    <x:scenario label="bare value in sf">
      <x:context mode="fieldTemplate">
        <bf2marc:sf code="a">test</bf2marc:sf>
      </x:context>
      <x:expect label="...should generate frame for target MARC subfield with bare value">
        <marc:subfield code="a">test</marc:subfield>
      </x:expect>
    </x:scenario>

    <x:scenario label="Processing rules in sf">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:sf code="a" repeatable="false">
            <bf2marc:switch>
              <bf2marc:case test="bf:mainTitle">title from bf:mainTitle</bf2marc:case>
              <bf2marc:case test="rdfs:label">title from rdfs:label</bf2marc:case>
            </bf2marc:switch>
          </bf2marc:sf>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should create a variable to hold value"
                test="count(marc:datafield/xslt:variable[@name='v245-a'])=1"/>
      <x:expect label="...and use that variable to decide whether to generate the subfield"
                test="marc:datafield/xslt:if/@test='$v245-a != '''''"/>
    </x:scenario>
  </x:scenario>

  <x:scenario label="chopPunct attribute in sf">
    <x:context mode="fieldTemplate">
      <bf2marc:df tag="245">
        <bf2marc:sf code="a" chopPunct="true">
          <bf2marc:select xpath="bf:mainTitle"/>
        </bf2marc:sf>
      </bf2marc:df>
    </x:context>
    <x:expect label="...should call tChopPunct template to process value"
              test="marc:datafield/xslt:for-each/marc:subfield/xslt:call-template/@name = 'tChopPunct'"/>
  </x:scenario>

  <x:scenario label="Rule building blocks">
    <x:scenario label="Simple select element">
      <x:context mode="fieldTemplate">
        <bf2marc:select xpath="rdfs:label"/>
      </x:context>
      <x:expect label="...should generate a for-each loop over the xpath">
        <xslt:for-each select="rdfs:label">
          <xslt:value-of select="."/>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="Simple variable">
      <x:context mode="fieldTemplate">
        <bf2marc:select xpath="rdfs:label">
          <bf2marc:var name="vTestVar" xpath="'some value'"/>
        </bf2marc:select>
      </x:context>
      <x:expect label="...should generate an xsl variable definition">
        <xslt:for-each select="rdfs:label">
          <xslt:variable name="vTestVar" select="'some value'"/>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="Complex variable">
      <x:context mode="fieldTemplate">
        <bf2marc:select xpath="bf:Work/*">
          <bf2marc:var name="vTag">
            <bf2marc:switch>
              <bf2marc:case test="local-name()='translationOf'">765</bf2marc:case>
            </bf2marc:switch>
          </bf2marc:var>
        </bf2marc:select>
      </x:context>
      <x:expect label="...should generate xsl variable with inner processing">
        <xslt:for-each select="bf:Work/*">
          <xslt:variable name="vTag">
            <xslt:choose>
              <xslt:when test="local-name()='translationOf'"><xslt:text>765</xslt:text></xslt:when>
            </xslt:choose>
          </xslt:variable>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="select within sf element">
      <x:context mode="fieldTemplate">
        <bf2marc:sf code="a">
          <bf2marc:select xpath="rdfs:label"/>
        </bf2marc:sf>
      </x:context>
      <x:expect label="...should generate the frame of the target MARC subfield">
        <xslt:for-each select="rdfs:label">
          <marc:subfield code="a"><xslt:value-of select="."/></marc:subfield>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="select within non-repeatable field or subfield">
      <x:context mode="generateTemplates">
        <bf2marc:cf tag="001">
          <bf2marc:context xpath="bf:Instance/bf:title/bf:Title">
            <bf2marc:select xpath="rdfs:label"/>
          </bf2marc:context>
        </bf2marc:cf>
      </x:context>
      <x:expect label="...should only allow one pass through the loop"
                test="xslt:template//xslt:for-each/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>

    <x:scenario label="select with bare value">
      <x:context mode="fieldTemplate">
        <bf2marc:select xpath="rdfs:label">test value</bf2marc:select>
      </x:context>
      <x:expect label="...should generate xsl:text node with value">
        <xslt:for-each select="rdfs:label">
          <xslt:text>test value</xslt:text>
        </xslt:for-each>
      </x:expect>
    </x:scenario>

    <x:scenario label="switch/case">
      <x:context mode="fieldTemplate">
        <bf2marc:switch>
          <bf2marc:case test="1=1"/>
          <bf2marc:case test="1=0"/>
          <bf2marc:case test="default"/>
        </bf2marc:switch>
      </x:context>
      <x:expect label="...should generate an xsl:choose nodeset">
        <xslt:choose>
          <xslt:when test="1=1"/>
          <xslt:when test="1=0"/>
          <xslt:otherwise/>
        </xslt:choose>
      </x:expect>
    </x:scenario>

    <x:scenario label="case with bare value">
      <x:context mode="fieldTemplate">
        <bf2marc:switch>
          <bf2marc:case test="1=1">test</bf2marc:case>
        </bf2marc:switch>
      </x:context>
      <x:expect label="...should generate xsl:text node with value">
        <xslt:choose>
          <xslt:when test="1=1"><xslt:text>test</xslt:text></xslt:when>
        </xslt:choose>
      </x:expect>
    </x:scenario>

    <x:scenario label="case with select element">
      <x:context mode="fieldTemplate">
        <bf2marc:switch>
          <bf2marc:case test="bf:mainTitle"><bf2marc:select xpath="bf:mainTitle"/></bf2marc:case>
          <bf2marc:case test="rdfs:label"><bf2marc:select xpath="rdfs:label"/></bf2marc:case>
        </bf2marc:switch>
      </x:context>
      <x:expect label="...should generate xsl:for-each within xsl:when">
        <xslt:choose>
          <xslt:when test="bf:mainTitle">
            <xslt:for-each select="bf:mainTitle">
              <xslt:value-of select="."/>
            </xslt:for-each>
          </xslt:when>
          <xslt:when test="rdfs:label">
            <xslt:for-each select="rdfs:label">
              <xslt:value-of select="."/>
            </xslt:for-each>
          </xslt:when>
        </xslt:choose>
      </x:expect>
    </x:scenario>

    <x:scenario label="switch/case/select within sf element">
      <x:context mode="fieldTemplate">
        <bf2marc:df tag="245">
          <bf2marc:ind1 default=" "/>
          <bf2marc:ind2 default=" "/>
          <bf2marc:sf code="a">
            <bf2marc:switch>
              <bf2marc:case test="bf:mainTitle"><bf2marc:select xpath="bf:mainTitle"/></bf2marc:case>
              <bf2marc:case test="rdfs:label"><bf2marc:select xpath="rdfs:label"/></bf2marc:case>
            </bf2marc:switch>
          </bf2marc:sf>
        </bf2marc:df>
      </x:context>
      <x:expect label="...should create variable that holds only a single value"
                test="marc:datafield/xslt:variable[@name='v245-a']/xslt:choose/xslt:when[1]/xslt:for-each/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>

    <x:scenario label="fixed-field/position">
      <x:context mode="fieldTemplate">
        <bf2marc:fixed-field>
          <bf2marc:position>test</bf2marc:position>
          <bf2marc:position><bf2marc:select xpath="rdfs:label"/></bf2marc:position>
        </bf2marc:fixed-field>
      </x:context>
      <x:expect label="...should generate XSL logic to generate concatenated values"
                test="count(/xslt:text) = 1 and count(//xslt:for-each) = 1"/>
      <x:expect label="...bare value should generate xsl:text node with value"
                test="/xslt:text = 'test'"/>
      <x:expect label="...select element should be non-repeatable"
                test="/xslt:variable/xslt:for-each/xslt:choose/xslt:when[1]/@test='position() = 1'"/>
    </x:scenario>

    <x:scenario label="lookup/lookupField">
      <x:context mode="fieldTemplate">
        <bf2marc:lookup map="test" targetField="code">
          <bf2marc:lookupField name="field1" xpath="rdfs:label"/>
          <bf2marc:lookupField name="field2">lookmeup</bf2marc:lookupField>
        </bf2marc:lookup>
      </x:context>
      <x:expect label="...lookupField with xpath attribute should generate variable"
                test="count(/xslt:variable[@name='vfield1']) = 1"/>
      <x:expect label="...with value from xpath"
                test="/xslt:variable[@name='vfield1']/xslt:value-of/@select = 'rdfs:label'"/>
      <x:expect label="...lookup creates XPath expression to pull value from map"
                test="count(/xslt:value-of/@select) = 1"/>
      <x:expect label="...lookupField with xpath uses variable in select"
                test="contains(/xslt:value-of/@select,'field1=$vfield1') = true()"/>
      <x:expect label="...lookupField with bare value uses string in select"
                test="contains(/xslt:value-of/@select,'lookmeup') = true()"/>
    </x:scenario>

    <x:scenario label="transform element">
      <x:context mode="fieldTemplate">
        <bf2marc:transform>
          <xslout:text>test</xslout:text>
        </bf2marc:transform>
      </x:context>
      <x:expect label="...XSL should be copied into output stylesheet">
        <xslt:text>test</xslt:text>
      </x:expect>
    </x:scenario>
  </x:scenario>

</x:description>
